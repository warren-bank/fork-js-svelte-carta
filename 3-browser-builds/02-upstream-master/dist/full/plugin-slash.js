import { s as scale, f as fade } from './index-C-FJF2Kj.js';
import { S as SvelteComponent, i as init, n as not_equal, a as empty, c as insert, t as transition_in, g as group_outros, f as transition_out, h as check_outros, j as detach, o as onMount, W as onDestroy, e as element, b as attr, X as action_destroyer, C as add_render_callback, Y as create_in_transition, Z as create_out_transition, E as destroy_each, F as text, d as append, G as set_data, s as binding_callbacks, l as listen } from './index-wUOa59Jt.js';
import { e as ensure_array_like } from './each-evIjbRfr.js';
import { g as getDefaultExportFromCjs } from './_commonjsHelpers-CSOnQ4_A.js';

/* ..\..\1-builds\02-upstream-master\packages\plugin-slash\dist\Slash.svelte generated by Svelte v4.2.18 */

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[20] = list[i][0];
	child_ctx[3] = list[i][1];
	child_ctx[21] = list;
	child_ctx[22] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[23] = list[i];
	child_ctx[24] = list;
	child_ctx[25] = i;
	return child_ctx;
}

// (98:10) {#if visible && filteredSnippets.length > 0}
function create_if_block(ctx) {
	let div;
	let div_intro;
	let div_outro;
	let current;
	let mounted;
	let dispose;
	let each_value = ensure_array_like(/*groupedSnippets*/ ctx[8]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div, "class", "carta-slash svelte-lh2dfi");
		},
		m(target, anchor) {
			insert(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}

			current = true;

			if (!mounted) {
				dispose = action_destroyer(/*carta*/ ctx[0].bindToCaret(div));
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty & /*groupedSnippets, getSnippetIndex, hoveringIndex, snippetsElements, useSnippet*/ 1872) {
				each_value = ensure_array_like(/*groupedSnippets*/ ctx[8]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i(local) {
			if (current) return;

			if (local) {
				add_render_callback(() => {
					if (!current) return;
					if (div_outro) div_outro.end(1);
					div_intro = create_in_transition(div, /*inTransition*/ ctx[1], {});
					div_intro.start();
				});
			}

			current = true;
		},
		o(local) {
			if (div_intro) div_intro.invalidate();

			if (local) {
				div_outro = create_out_transition(div, /*outTransition*/ ctx[2], {});
			}

			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(div);
			}

			destroy_each(each_blocks, detaching);
			if (detaching && div_outro) div_outro.end();
			mounted = false;
			dispose();
		}
	};
}

// (98:237) {#each snippets as snippet, elemIndex}
function create_each_block_1(ctx) {
	let button;
	let span0;
	let t0_value = /*snippet*/ ctx[23].title + "";
	let t0;
	let span1;
	let t1_value = /*snippet*/ ctx[23].description + "";
	let t1;
	let button_class_value;
	let groupIndex = /*groupIndex*/ ctx[22];
	let elemIndex = /*elemIndex*/ ctx[25];
	let mounted;
	let dispose;
	const assign_button = () => /*button_binding*/ ctx[12](button, groupIndex, elemIndex);
	const unassign_button = () => /*button_binding*/ ctx[12](null, groupIndex, elemIndex);

	function click_handler() {
		return /*click_handler*/ ctx[13](/*snippet*/ ctx[23]);
	}

	return {
		c() {
			button = element("button");
			span0 = element("span");
			t0 = text(t0_value);
			span1 = element("span");
			t1 = text(t1_value);
			attr(span0, "class", "carta-snippet-title svelte-lh2dfi");
			attr(span1, "class", "carta-snippet-description svelte-lh2dfi");

			attr(button, "class", button_class_value = /*getSnippetIndex*/ ctx[9](/*groupIndex*/ ctx[22], /*elemIndex*/ ctx[25]) === /*hoveringIndex*/ ctx[4]
			? 'carta-active'
			: '');
		},
		m(target, anchor) {
			insert(target, button, anchor);
			append(button, span0);
			append(span0, t0);
			append(button, span1);
			append(span1, t1);
			assign_button();

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*groupedSnippets*/ 256 && t0_value !== (t0_value = /*snippet*/ ctx[23].title + "")) set_data(t0, t0_value);
			if (dirty & /*groupedSnippets*/ 256 && t1_value !== (t1_value = /*snippet*/ ctx[23].description + "")) set_data(t1, t1_value);

			if (dirty & /*hoveringIndex*/ 16 && button_class_value !== (button_class_value = /*getSnippetIndex*/ ctx[9](/*groupIndex*/ ctx[22], /*elemIndex*/ ctx[25]) === /*hoveringIndex*/ ctx[4]
			? 'carta-active'
			: '')) {
				attr(button, "class", button_class_value);
			}

			if (groupIndex !== /*groupIndex*/ ctx[22] || elemIndex !== /*elemIndex*/ ctx[25]) {
				unassign_button();
				groupIndex = /*groupIndex*/ ctx[22];
				elemIndex = /*elemIndex*/ ctx[25];
				assign_button();
			}
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			unassign_button();
			mounted = false;
			dispose();
		}
	};
}

// (98:135) {#each groupedSnippets as [group, snippets], groupIndex}
function create_each_block(ctx) {
	let span;
	let t_value = /*group*/ ctx[20] + "";
	let t;
	let each_1_anchor;
	let each_value_1 = ensure_array_like(/*snippets*/ ctx[3]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			span = element("span");
			t = text(t_value);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			attr(span, "class", "carta-slash-group svelte-lh2dfi");
		},
		m(target, anchor) {
			insert(target, span, anchor);
			append(span, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert(target, each_1_anchor, anchor);
		},
		p(ctx, dirty) {
			if (dirty & /*groupedSnippets*/ 256 && t_value !== (t_value = /*group*/ ctx[20] + "")) set_data(t, t_value);

			if (dirty & /*getSnippetIndex, hoveringIndex, snippetsElements, useSnippet, groupedSnippets*/ 1872) {
				each_value_1 = ensure_array_like(/*snippets*/ ctx[3]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d(detaching) {
			if (detaching) {
				detach(span);
				detach(each_1_anchor);
			}

			destroy_each(each_blocks, detaching);
		}
	};
}

function create_fragment(ctx) {
	let if_block_anchor;
	let if_block = /*visible*/ ctx[7] && /*filteredSnippets*/ ctx[5].length > 0 && create_if_block(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, [dirty]) {
			if (/*visible*/ ctx[7] && /*filteredSnippets*/ ctx[5].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*visible, filteredSnippets*/ 160) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i(local) {
			transition_in(if_block);
		},
		o(local) {
			transition_out(if_block);
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) if_block.d(detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { carta } = $$props;
	let { snippets } = $$props;
	let { inTransition } = $$props;
	let { outTransition } = $$props;
	let visible = false;
	let hoveringIndex = 0;
	let filter = "";
	let slashPosition = 0;
	let filteredSnippets = snippets;
	let groupedSnippets;
	let snippetsElements = Array(snippets.length);

	onMount(() => {
		carta.input?.textarea.addEventListener("keydown", handleKeyDown);
		carta.input?.textarea.addEventListener("keyup", handleKeyUp);
		carta.input?.textarea.addEventListener("click", hide);
		carta.input?.textarea.addEventListener("blur", hide);
	});

	onDestroy(() => {
		carta.input?.textarea.removeEventListener("keydown", handleKeyDown);
		carta.input?.textarea.removeEventListener("keyup", handleKeyUp);
		carta.input?.textarea.removeEventListener("click", hide);
		carta.input?.textarea.removeEventListener("blur", hide);
	});

	function hide() {
		$$invalidate(7, visible = false);
	}

	function handleKeyDown(e) {
		if (!carta.input) return;

		if (visible) {
			if (e.key === " " || e.key === "Escape" || e.key === "Backspace" && filter === "") {
				$$invalidate(7, visible = false);
			} else if (e.key === "Enter") {
				e.preventDefault();
				const selectedSnippet = filteredSnippets.at(hoveringIndex);
				if (!selectedSnippet) return;
				useSnippet(selectedSnippet);
				$$invalidate(7, visible = false);
			} else {
				if (e.key === "ArrowUp") {
					e.preventDefault();
					$$invalidate(4, hoveringIndex = (hoveringIndex - 1 + filteredSnippets.length) % filteredSnippets.length);
				} else if (e.key === "ArrowDown") {
					e.preventDefault();
					$$invalidate(4, hoveringIndex = (hoveringIndex + 1 + filteredSnippets.length) % filteredSnippets.length);
				}
			}
		} else if (e.key === "/") {
			$$invalidate(7, visible = true);
			slashPosition = carta.input.textarea.selectionStart + 1;
			filter = "";
		}
	}

	function handleKeyUp(e) {
		if (!carta.input) return;
		if (!visible) return;

		if (carta.input.textarea.selectionStart < slashPosition) {
			$$invalidate(7, visible = false);
		} else if (e.key.length === 1 || e.key === "Backspace") {
			filter = carta.input.textarea.value.slice(slashPosition, carta.input.textarea.selectionStart);
			$$invalidate(5, filteredSnippets = snippets.filter(snippetFilter));
			$$invalidate(4, hoveringIndex = 0);
		}
	}

	const snippetFilter = snippet => {
		if (!filter) return true;
		const lower = filter.toLowerCase();
		return snippet.title.toLowerCase().includes(lower) || snippet.description.toLowerCase().includes(lower);
	};

	const groupBy = (items, key) => items.reduce(
		(result, item) => ({
			...result,
			[item[key]]: [...result[item[key]] || [], item]
		}),
		{}
	);

	const getSnippetIndex = (groupIndex, elemIndex) => {
		const prevCount = groupedSnippets.filter((_, i) => i < groupIndex).reduce((acc, [,curr]) => acc + curr.length, 0);
		return prevCount + elemIndex;
	};

	function useSnippet(snippet) {
		if (!carta.input) return;
		carta.input.removeAt(slashPosition - 1, filter.length + 1);
		$$invalidate(0, carta.input.textarea.selectionStart = slashPosition - 1, carta);
		snippet.action(carta.input);
		carta.input.update();
	}

	function button_binding($$value, groupIndex, elemIndex) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			snippetsElements[getSnippetIndex(groupIndex, elemIndex)] = $$value;
			$$invalidate(6, snippetsElements);
		});
	}

	const click_handler = snippet => useSnippet(snippet);

	$$self.$$set = $$props => {
		if ('carta' in $$props) $$invalidate(0, carta = $$props.carta);
		if ('snippets' in $$props) $$invalidate(3, snippets = $$props.snippets);
		if ('inTransition' in $$props) $$invalidate(1, inTransition = $$props.inTransition);
		if ('outTransition' in $$props) $$invalidate(2, outTransition = $$props.outTransition);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*filteredSnippets*/ 32) {
			$$invalidate(8, groupedSnippets = Object.entries(groupBy(filteredSnippets, "group")));
		}

		if ($$self.$$.dirty & /*filteredSnippets, hoveringIndex, snippetsElements*/ 112) {
			{
				const hovering = filteredSnippets.at(hoveringIndex);

				if (hovering) {
					const snipElem = snippetsElements[hoveringIndex];
					snipElem?.scrollIntoView({ behavior: "smooth", block: "nearest" });
				}
			}
		}
	};

	return [
		carta,
		inTransition,
		outTransition,
		snippets,
		hoveringIndex,
		filteredSnippets,
		snippetsElements,
		visible,
		groupedSnippets,
		getSnippetIndex,
		useSnippet,
		groupBy,
		button_binding,
		click_handler
	];
}

class Slash extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, not_equal, {
			carta: 0,
			snippets: 3,
			inTransition: 1,
			outTransition: 2,
			groupBy: 11
		});
	}

	get groupBy() {
		return this.$$.ctx[11];
	}
}

/**
 * https://github.com/gre/bezier-easing
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === 'function';

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
 for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
   var currentSlope = getSlope(aGuessT, mX1, mX2);
   if (currentSlope === 0.0) {
     return aGuessT;
   }
   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
   aGuessT -= currentX / currentSlope;
 }
 return aGuessT;
}

function LinearEasing (x) {
  return x;
}

var src = function bezier (mX1, mY1, mX2, mY2) {
  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {
    throw new Error('bezier x values must be in [0, 1] range');
  }

  if (mX1 === mY1 && mX2 === mY2) {
    return LinearEasing;
  }

  // Precompute samples table
  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  for (var i = 0; i < kSplineTableSize; ++i) {
    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
  }

  function getTForX (aX) {
    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }

  return function BezierEasing (x) {
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) {
      return 0;
    }
    if (x === 1) {
      return 1;
    }
    return calcBezier(getTForX(x), mY1, mY2);
  };
};

var BezierEasing = /*@__PURE__*/getDefaultExportFromCjs(src);

function insertLine(input, string) {
    const line = input.getLine();
    if (line.value !== '') {
        input.insertAt(line.end, `\n${string}`);
        const newPos = line.end + string.length + 1;
        input.textarea.selectionStart = newPos;
        input.textarea.selectionEnd = newPos;
    }
    else {
        input.insertAt(line.end, `${string}`);
        const newPos = line.end + string.length;
        input.textarea.selectionStart = newPos;
        input.textarea.selectionEnd = newPos;
    }
}
/**
 * Default slash snippets.
 */
const defaultSnippets = [
    {
        id: 'bigHeading',
        title: 'Heading 1',
        description: 'Big section heading',
        group: 'Basic',
        action: (input) => insertLine(input, '# ')
    },
    {
        id: 'mediumHeading',
        title: 'Heading 2',
        description: 'Medium section heading',
        group: 'Basic',
        action: (input) => insertLine(input, '## ')
    },
    {
        id: 'smallHeading',
        title: 'Heading 3',
        description: 'Small section heading',
        group: 'Basic',
        action: (input) => insertLine(input, '### ')
    },
    {
        id: 'numberedList',
        title: 'Numbered List',
        description: 'Create a list with numbering',
        group: 'Basic',
        action: (input) => insertLine(input, '1. ')
    },
    {
        id: 'bulletedList',
        title: 'Bulleted List',
        description: 'Create a bulleted list',
        group: 'Basic',
        action: (input) => insertLine(input, '- ')
    },
    {
        id: 'taskList',
        title: 'Task List',
        description: 'Create a task list',
        group: 'Basic',
        action: (input) => insertLine(input, '- [ ] ')
    },
    {
        id: 'quote',
        title: 'Quote',
        description: 'Create a quote',
        group: 'Basic',
        action: (input) => insertLine(input, '> ')
    },
    {
        id: 'code',
        title: 'Code',
        description: 'Add a code block',
        group: 'Basic',
        action: (input) => {
            insertLine(input, '```\n');
            const pos = input.textarea.selectionStart;
            insertLine(input, '\n```');
            input.textarea.setSelectionRange(pos, pos);
        }
    }
];

//export * from './default.css?inline';
/**
 * Carta slash extension.
 * @param options Extension options.
 * @returns The slash extension.
 */
const slash = (options) => {
    const snippets = defaultSnippets.filter((snippet) => options?.disableDefaultSnippets === true
        ? false
        : !options?.disableDefaultSnippets?.includes(snippet.id));
    snippets.push(...(options?.snippets ?? []));
    const inTransition = options?.inTransition ??
        ((node) => scale(node, {
            duration: 150,
            easing: BezierEasing(0.05, 0.68, 0.2, 1.15)
        }));
    const outTransition = options?.inTransition ??
        ((node) => fade(node, {
            duration: 100
        }));
    const slashComponent = {
        component: Slash,
        props: {
            snippets,
            inTransition,
            outTransition
        },
        parent: 'input'
    };
    return {
        components: [slashComponent]
    };
};

export { slash as default };
